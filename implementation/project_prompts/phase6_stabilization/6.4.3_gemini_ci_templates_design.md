# CI Templates & Workflows Design

**Task ID:** 6.4.3
**Phase:** 6.4 (Engineering Framework & Tooling)
**Author:** Gemini Antimatter
**Status:** Approved Design

## 1. Overview
Reliable CI is critical for the Lattice Lock Framework. This design defines standard workflows and dependency management to ensure tests pass consistently across environments.

## 2. GitHub Actions Workflow

We define a primary workflow `.github/workflows/ci.yml` that runs on every PR.

```yaml
name: Lattice Lock CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  validate:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11"]

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev]"

    - name: Lint with Ruff
      run: |
        # Quick check for syntax errors
        ruff check src tests

    - name: Unit Tests
      run: |
        pytest tests/unit

    - name: Governance Check (Sheriff)
      run: |
        lattice-lock sheriff .
```

## 3. Dependency Groups (`pyproject.toml`)

We must explicitly define dependency groups to avoid "ModuleNotFoundError" in CI.

```toml
[project]
name = "lattice-lock-framework"
dependencies = [
    "pydantic>=2.0",
    "typer>=0.9.0",    # CLI framework (replacing scripts)
    "rich>=13.0",      # CLI formatting
    "pyyaml>=6.0",     # Registry parsing
    "aiohttp>=3.9.0",  # API clients
    "jinja2>=3.1",     # Code generation
    "sqlmodel>=0.0.14",# Optional ORM
]

[project.optional-dependencies]
dev = [
    "pytest>=7.4",
    "pytest-asyncio>=0.23",
    "pytest-cov>=4.1",
    "ruff>=0.1.6",
    "hypothesis>=6.90", # Gauntlet fuzzing
]
```

**Identified Missing Dependencies:**
*   `typer` (was missing, needed for new CLI)
*   `rich` (was missing)
*   `jinja2` (needed for templates)

## 4. Secrets & Mocking Strategy

**Problem:** Cannot share API keys in public CI.
**Solution:**
1.  **Mocking:** Use `pytest-mock` or custom `MockProvider` class for unit tests.
2.  **Skip Integration:** Use `@pytest.mark.integration` decorator.
3.  **Config:** In `conftest.py`, skip integration tests if `OPENAI_API_KEY` is not present in Env.

```python
# conftest.py
def pytest_collection_modifyitems(config, items):
    if not os.environ.get("OPENAI_API_KEY"):
        skip_integration = pytest.mark.skip(reason="No API key found")
        for item in items:
            if "integration" in item.keywords:
                item.add_marker(skip_integration)
```

## 5. Implementation Tasks (Devin AI)

1.  **Update `pyproject.toml`**: Add missing dependencies (`typer`, `rich`, `jinja2`).
2.  **Create `.github/workflows/ci.yml`**: Implement the matrix workflow.
3.  **Update `conftest.py`**: Implement skipping logic for integration tests without keys.
4.  **Fix Import Errors**: Ensure tests run locally with `pip install -e .`
