# Task 6.3.3: Cost & Telemetry Strategy Design

**Status:** Approved
**Owner:** Gemini Antimatter
**Implementation Task:** 6.3.4 (Devin AI)

---

## 1. Cost Tracking Scope

We will implement a multi-layered cost tracking system to ensure transparency for both individual actions and project lifetimes.

*   **Per-Call Tracking:** Every LLM interaction (completion, embedding) calculates tokens (in/out) and estimated cost using the Model Registry pricing.
*   **Per-Session Aggregation:** The CLI session maintains a running total of costs.
*   **Per-Project Persistence:** Costs are saved to a local database to track "burn rate" over time.
*   **Breakdowns:**
    *   By Provider (e.g., OpenAI vs Anthropic spend).
    *   By Model Class (e.g., Coding vs Reasoning spend).

## 2. Data Model

```python
@dataclass
class UsageRecord:
    timestamp: datetime
    session_id: str
    trace_id: str
    model_id: str
    provider: str
    task_type: str
    input_tokens: int
    output_tokens: int
    cost_usd: float
    metadata: Dict[str, Any] = field(default_factory=dict)
```

## 3. Storage Strategy

**Recommendation: SQLite (`.lattice/cost.db`)**

*   **Rationale:**
    *   Zero dependency (built into Python).
    *   Single file (easy to gitignore).
    *   Structured SQL allows complex queries (e.g., "Give me total cost for last week by provider").
    *   JSON is too fragile for appended logs; CSV is hard to query.

*   **Schema:**
    *   `usage_logs` table matching `UsageRecord`.

## 4. API Surface

**`src/lattice_lock_orchestrator/cost/tracker.py`**

```python
class CostTracker:
    def record_transaction(self, response: APIResponse, task_type: TaskType):
        ...
        
    def get_session_summary(self, session_id: str) -> float:
        ...
        
    def get_project_summary(self, days: int = 30) -> Dict[str, float]:
        ...
```

**CLI Commands:**
*   `lattice-lock cost`: Shows total spend for current project (all time).
*   `lattice-lock cost --session`: Shows spend for current/last session.
*   `lattice-lock cost --report`: Generates a breakdown table by provider/model.

## 5. Integration Points

*   **Orchestrator Core:** In `orchestrator.generate()`, after receiving a response, immediately call `cost_tracker.record_transaction()`.
*   **Token Counting:**
    *   Use provider response usage fields (reliable).
    *   Fallback: Use `tiktoken` (approximate) if provider yields raw text without usage stats (rare for APIs, common for local).
    *   For Ollama: Use estimated tokens (or exact if API provides).

## 6. Implementation Tasks (For Devin AI)

1.  **[ ] Create `src/lattice_lock_orchestrator/cost/` module:**
    *   `models.py` (UsageRecord)
    *   `storage.py` (SQLite wrapper)
    *   `tracker.py` (Business logic)
2.  **[ ] Update `Orchestrator`:**
    *   Inject `CostTracker` singleton.
    *   Call record hooks on every generation.
3.  **[ ] Implement CLI Command:**
    *   `src/lattice_lock_cli/commands/cost.py`
    *   Rich table output.
4.  **[ ] Add Unit Tests:**
    *   Verify cost validation math.
    *   Verify SQLite persistence and retrieval.
