# Task 6.1.1 - Orchestrator Capabilities Contract Design

**Tool:** Gemini Antimatter (Design Doc)
**Phase:** 6.1 - Breaking Issues / Orchestrator Contract Hardening
**Dependencies:** None
**Owner:** Gemini Antimatter

---

## Prompt for Gemini Antimatter

You are helping maintain architectural documentation for the lattice-lock-framework.

Task ID: 6.1.1 - Orchestrator Capabilities Contract Design

### Context

The current implementation has a critical mismatch between `ModelCapabilities` and its consumers:

**Current `ModelCapabilities` in `src/lattice_lock_orchestrator/types.py`:**
- `coding_score: float`
- `reasoning_score: float`
- `context_window: int`
- `cost_per_1k_tokens: float`
- `provider: Provider`
- `model_id: str`

**CLI in `scripts/orchestrator_cli.py` references non-existent attributes:**
- Line 86: `model.supports_reasoning` (doesn't exist)
- Line 88: `model.code_specialized` (doesn't exist)
- Line 95, 150: `model.task_scores` (doesn't exist)
- Line 277: `TaskType.VISION` (not in enum)

**Current `TaskType` enum in `types.py`:**
- CODE_GENERATION, DEBUGGING, ARCHITECTURAL_DESIGN, DOCUMENTATION, TESTING, DATA_ANALYSIS, GENERAL, REASONING

This causes `AttributeError` at runtime when using the CLI.

### Goals

Write a design document in markdown with these sections:

1. **Contract Definition**
   - Which fields MUST exist on `ModelCapabilities` for CLI output and routing?
   - Define the complete field list with types
   - Specify which fields are required vs optional with defaults

2. **Field Semantics**
   - Should we use explicit booleans (`supports_reasoning`, `code_specialized`) or derive from numeric scores?
   - How should `task_scores` be represented? Options:
     - Explicit `dict[TaskType, float]` on each model
     - Derived at runtime from scoring functions
     - Hybrid approach
   - Recommendation with rationale

3. **TaskType Enum Updates**
   - Should `VISION` be added to the enum?
   - If yes: define semantics and which models support it
   - If no: how to handle/remove existing references?
   - Any other missing task types?

4. **Migration Strategy**
   - Safe defaults for new fields (backwards compatibility)
   - How existing model definitions should be updated
   - Validation to ensure all models have required fields

5. **Implementation Tasks**
   List concrete tasks for Devin AI to implement, including:
   - Specific files to modify
   - Field names and types to add
   - Tests to write

### Output Requirements

- Concrete field names, types, and file paths
- Clear decision on booleans vs derived values
- Clear decision on VISION task type
- Migration notes for existing code

### Reference Files

- `src/lattice_lock_orchestrator/types.py` - Current type definitions
- `src/lattice_lock_orchestrator/registry.py` - Model registry
- `scripts/orchestrator_cli.py` - CLI that uses these types
- `models/model_registry.md` - Documentation of 63 models
