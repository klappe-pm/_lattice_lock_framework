# from lattice.yaml to Gauntlet Tests: A Governance Core Walkthrough

**Task ID:** 6.2.4
**Phase:** 6.2 (Governance Core Loop)
**Author:** Gemini Antimatter
**Status:** Approved Documentation

## 1. Introduction

The **Governance Core** is the "legislative branch" of the Lattice Lock Framework. Instead of writing boilerplate validation logic or manually checking architectural constraints, you define them in a `lattice.yaml` schema. The framework then compiles this schema into enforcement artifacts.

**Benefits:**
*   **Single Source of Truth:** Your data model and rules live in one place.
*   **Semantic Testing:** We generate tests that fuzz your logic to find edge cases.
*   **Zero Boilerplate:** Pydantic models and SQL tables are auto-generated.

## 2. Prerequisites

*   Python 3.10+
*   Lattice Lock Framework installed:
    ```bash
    pip install lattice-lock
    ```
*   A project structure (minimal):
    ```text
    my-project/
    ├── lattice.yaml
    └── src/
    ```

## 3. Step 1: Define Your Schema

Create a file named `lattice.yaml` in your project root.

```yaml
version: "2.1"
generated_module: "my_project_types"

entities:
  BankAccount:
    fields:
      id: "uuid"
      owner: "str"
      balance: "decimal"
      status: "enum(active, frozen, closed)"
    
    constraints:
      owner:
        min_length: 3
      balance:
        gte: 0.0  # Constraint: Balance cannot be negative
    
    ensures:
      - "status == 'frozen' implies balance >= 0"
      - "status == 'closed' implies balance == 0"
```

## 4. Step 2: Validate Schema

Before compiling, ensure your schema is valid.

```bash
lattice-lock validate --schema-only
```

**Output:**
```text
✓ lattice.yaml is valid
```

If you made a mistake (e.g., used an invalid type), the validator will explain exactly where.

## 5. Step 3: Compile to Artifacts

Turn your YAML into Python code.

```bash
lattice-lock compile
```

This generates:
1.  `src/generated/models.py`: Pydantic models with your fields and constraints.
2.  `tests/contracts/test_bankaccount.py`: Gauntlet property tests.

## 6. Step 4: Run Gauntlet Tests

Gauntlet runs "Property-Based Tests" (via Hypothesis). It tries thousands of random valid inputs to see if it can break your `ensures` clauses or constraints.

```bash
lattice-lock gauntlet
```

**Output:**
```text
Running Semantic Contract Tests...
✓ BankAccount: owner min_length=3 (Passed 100 examples)
✓ BankAccount: balance >= 0.0 (Passed 100 examples)
✓ BankAccount: ensure(status='frozen' -> balance >= 0) (Passed 100 examples)
✓ BankAccount: ensure(status='closed' -> balance == 0) (Passed 100 examples)

All contracts verified.
```

## 7. Step 5: Use Generated Code

Now you can use these models in your actual application code without writing them yourself.

```python
from src.generated.models import BankAccount, BankAccountStatus
from uuid import uuid4
from decimal import Decimal

# Valid creation
account = BankAccount(
    id=uuid4(),
    owner="Alice",
    balance=Decimal("100.00"),
    status=BankAccountStatus.active
)

# Invalid creation - raises ValidationError
try:
    bad_account = BankAccount(
        id=uuid4(),
        owner="Bob",
        balance=Decimal("-50.00"), # Violates constraint
        status=BankAccountStatus.active
    )
except ValueError as e:
    print(e)
```

## 8. Integration with Sheriff

Sheriff ensures your code structure respects the framework's layering rules. While Governance Core handles *data* rules, Sheriff handles *architecture* rules.

Run Sheriff to check imports and dependency flows:
```bash
lattice-lock sheriff
```

## 9. Troubleshooting

**Error: "Unknown type 'money'"**
*   **Cause:** You used a field type not supported by the spec.
*   **Fix:** Use `decimal` for money, or `float`.

**Error: "Constraint 'gt' not applicable to type 'str'"**
*   **Cause:** You tried to use a numeric constraint on a string.
*   **Fix:** Use `min_length` instead.

**Gauntlet fails with "Falsifying example"**
*   **Cause:** Gauntlet found an input that breaks your rules.
*   **Fix:** Your `ensures` clause might be logically inconsistent with your constraints. Adjust the logic in `lattice.yaml`.
