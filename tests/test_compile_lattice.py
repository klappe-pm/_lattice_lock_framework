"""
Tests for the compile_lattice API and CLI.

Validates:
1. Compilation of valid schemas
2. Error handling for invalid schemas
3. Generation of Pydantic models
4. Generation of Gauntlet tests
5. CLI functionality
"""
import pytest
import subprocess
import sys
from pathlib import Path

from lattice_lock.compile import compile_lattice, CompilationResult


PROJECT_ROOT = Path(__file__).parent.parent
BASIC_EXAMPLE = PROJECT_ROOT / "examples" / "basic" / "lattice.yaml"
ADVANCED_EXAMPLE = PROJECT_ROOT / "examples" / "advanced" / "lattice.yaml"
VALID_FIXTURE = PROJECT_ROOT / "tests" / "fixtures" / "valid_lattice.yaml"
INVALID_MISSING_VERSION = PROJECT_ROOT / "tests" / "fixtures" / "invalid_lattice_missing_version.yaml"


class TestCompileLatticeAPI:
    """Test the compile_lattice Python API."""

    def test_compile_basic_example(self, tmp_path):
        """Compile basic example schema successfully."""
        result = compile_lattice(
            schema_path=BASIC_EXAMPLE,
            output_dir=tmp_path,
        )

        assert result.success is True
        assert len(result.errors) == 0
        assert len(result.entities) > 0
        assert "User" in result.entities or "Post" in result.entities

    def test_compile_advanced_example(self, tmp_path):
        """Compile advanced example schema successfully."""
        result = compile_lattice(
            schema_path=ADVANCED_EXAMPLE,
            output_dir=tmp_path,
        )

        assert result.success is True
        assert len(result.errors) == 0
        assert len(result.entities) >= 3

    def test_compile_generates_pydantic(self, tmp_path):
        """Pydantic models should be generated by default."""
        result = compile_lattice(
            schema_path=BASIC_EXAMPLE,
            output_dir=tmp_path,
            generate_pydantic=True,
        )

        assert result.success is True
        pydantic_file = tmp_path / "models.py"
        assert pydantic_file in result.generated_files
        assert pydantic_file.exists()

        # Check content
        content = pydantic_file.read_text()
        assert "from pydantic import" in content
        assert "class" in content

    def test_compile_generates_gauntlet(self, tmp_path):
        """Gauntlet tests should be generated by default."""
        result = compile_lattice(
            schema_path=VALID_FIXTURE,
            output_dir=tmp_path,
            generate_gauntlet=True,
        )

        assert result.success is True
        gauntlet_dir = tmp_path / "gauntlet"
        assert gauntlet_dir.exists()

        # Check for test files
        test_files = list(gauntlet_dir.glob("test_contract_*.py"))
        assert len(test_files) > 0

    def test_compile_skip_pydantic(self, tmp_path):
        """Pydantic can be disabled."""
        result = compile_lattice(
            schema_path=BASIC_EXAMPLE,
            output_dir=tmp_path,
            generate_pydantic=False,
            generate_gauntlet=False,
        )

        assert result.success is True
        pydantic_file = tmp_path / "models.py"
        assert not pydantic_file.exists()

    def test_compile_generates_sqlmodel(self, tmp_path):
        """SQLModel can be optionally generated."""
        result = compile_lattice(
            schema_path=BASIC_EXAMPLE,
            output_dir=tmp_path,
            generate_sqlmodel=True,
        )

        assert result.success is True
        sqlmodel_file = tmp_path / "orm.py"
        assert sqlmodel_file in result.generated_files
        assert sqlmodel_file.exists()

        # Check content
        content = sqlmodel_file.read_text()
        assert "from sqlmodel import" in content

    def test_compile_invalid_schema_fails(self, tmp_path):
        """Invalid schemas should fail compilation."""
        result = compile_lattice(
            schema_path=INVALID_MISSING_VERSION,
            output_dir=tmp_path,
        )

        assert result.success is False
        assert len(result.errors) > 0
        assert any("version" in err.lower() for err in result.errors)

    def test_compile_nonexistent_file(self, tmp_path):
        """Nonexistent schema should fail with clear error."""
        result = compile_lattice(
            schema_path="/nonexistent/path/schema.yaml",
            output_dir=tmp_path,
        )

        assert result.success is False
        assert len(result.errors) > 0

    def test_compile_default_output_dir(self):
        """Default output dir should be schema_dir/generated."""
        result = compile_lattice(
            schema_path=BASIC_EXAMPLE,
            output_dir=None,
        )

        assert result.success is True
        expected_dir = BASIC_EXAMPLE.parent / "generated"
        # Check that files were generated in expected location
        for path in result.generated_files:
            assert expected_dir in path.parents or path.parent == expected_dir

    def test_compilation_result_structure(self, tmp_path):
        """CompilationResult should have correct structure."""
        result = compile_lattice(
            schema_path=BASIC_EXAMPLE,
            output_dir=tmp_path,
        )

        assert isinstance(result, CompilationResult)
        assert isinstance(result.success, bool)
        assert isinstance(result.generated_files, list)
        assert isinstance(result.warnings, list)
        assert isinstance(result.errors, list)
        assert isinstance(result.entities, list)


class TestCompileLatticeValidation:
    """Test validation during compilation."""

    def test_invalid_type_error(self, tmp_path):
        """Invalid field types should produce clear errors."""
        invalid_schema = PROJECT_ROOT / "tests" / "fixtures" / "invalid_lattice_bad_type.yaml"
        if not invalid_schema.exists():
            pytest.skip("Invalid type fixture not found")

        result = compile_lattice(
            schema_path=invalid_schema,
            output_dir=tmp_path,
        )

        assert result.success is False
        assert any("type" in err.lower() for err in result.errors)

    def test_constraint_validation(self, tmp_path):
        """Constraint validation should be enforced."""
        invalid_schema = PROJECT_ROOT / "tests" / "fixtures" / "invalid_lattice_numeric_constraint_on_string.yaml"
        if not invalid_schema.exists():
            pytest.skip("Constraint fixture not found")

        result = compile_lattice(
            schema_path=invalid_schema,
            output_dir=tmp_path,
        )

        assert result.success is False


class TestCompileLatticeGeneratedCode:
    """Test the generated code quality."""

    def test_pydantic_models_valid_python(self, tmp_path):
        """Generated Pydantic models should be valid Python."""
        result = compile_lattice(
            schema_path=BASIC_EXAMPLE,
            output_dir=tmp_path,
            generate_pydantic=True,
        )

        assert result.success
        pydantic_file = tmp_path / "models.py"

        # Compile to check for syntax errors
        content = pydantic_file.read_text()
        compile(content, str(pydantic_file), 'exec')

    def test_sqlmodel_classes_valid_python(self, tmp_path):
        """Generated SQLModel classes should be valid Python."""
        result = compile_lattice(
            schema_path=BASIC_EXAMPLE,
            output_dir=tmp_path,
            generate_sqlmodel=True,
        )

        assert result.success
        sqlmodel_file = tmp_path / "orm.py"

        # Compile to check for syntax errors
        content = sqlmodel_file.read_text()
        compile(content, str(sqlmodel_file), 'exec')


class TestCompileLatticeWithConstraints:
    """Test compilation of schemas with constraints."""

    def test_numeric_constraints_in_pydantic(self, tmp_path):
        """Numeric constraints should generate validators."""
        result = compile_lattice(
            schema_path=VALID_FIXTURE,
            output_dir=tmp_path,
            generate_pydantic=True,
        )

        assert result.success
        pydantic_file = tmp_path / "models.py"
        content = pydantic_file.read_text()

        # Should have field validators for constraints
        assert "field_validator" in content or "Field(" in content

    def test_ensures_clauses_generate_tests(self, tmp_path):
        """Ensures clauses should generate Gauntlet tests."""
        result = compile_lattice(
            schema_path=VALID_FIXTURE,
            output_dir=tmp_path,
            generate_gauntlet=True,
        )

        assert result.success
        gauntlet_dir = tmp_path / "gauntlet"
        test_files = list(gauntlet_dir.glob("test_contract_*.py"))

        # Each entity with ensures should have tests
        for test_file in test_files:
            content = test_file.read_text()
            assert "def test_" in content or "assert" in content


class TestCompileLatticeIntegration:
    """Integration tests for compile_lattice."""

    def test_full_compilation_workflow(self, tmp_path):
        """Test full compilation with all options enabled."""
        result = compile_lattice(
            schema_path=ADVANCED_EXAMPLE,
            output_dir=tmp_path,
            generate_pydantic=True,
            generate_sqlmodel=True,
            generate_gauntlet=True,
        )

        assert result.success

        # Check all expected files exist
        assert (tmp_path / "models.py").exists()
        assert (tmp_path / "orm.py").exists()
        assert (tmp_path / "gauntlet").is_dir()

        # Check file count
        assert len(result.generated_files) >= 3

    def test_compile_preserves_entity_relationships(self, tmp_path):
        """Entity relationships should be preserved in generated code."""
        result = compile_lattice(
            schema_path=ADVANCED_EXAMPLE,
            output_dir=tmp_path,
            generate_pydantic=True,
        )

        assert result.success
        content = (tmp_path / "models.py").read_text()

        # Advanced example should have multiple related entities
        assert result.entities  # Should have entities
